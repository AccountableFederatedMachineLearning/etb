<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Factsheet</title>

  <style>
    body {
      margin: 40px auto;
      max-width: 60em;
      line-height: 1.6;
      padding: 0 10px;
    }

    .fact {}

    .green {
      text-decoration: underline green;
    }

    .yellow {
      background-color: lightyellow;
    }
  </style>

  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="/socket.io/socket.io.js"></script>

  <!-- Don't use this in production: -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- These are a few simple react components for writing factsheets.
       See the body for examples of how to use them. -->
  <script type="text/babel">

    function getFirstCN(dn) {
      for (let i of dn) {
        if (i.CN) {
          return i.CN;
        }
      }
      return "?";
    }

    function jsonOfConstant(s) {
      if (s[0] === '\'' && s[s.length - 1] === '\'') {
        s = s.substring(1, s.length - 1);
      }
      try {
        return JSON.parse(s);
      }
      catch (e) {
        return null
      }
    }

    function FormattedFact(props) {
      var format = props.format;
      let args = props.args;
      try {
        let text =
          format.length === 1
            ? format(props.args)
            : format.length === 3
              ? format(props.principal, props.symbol, props.args)
              : format;
        return <>{text}</>;
      } catch (e) {
        return <>{"formatting error: " + e}</>
      }
    }

    function FactInstancesOfPrincipal(props) {
      let argColors = props.argColors;
      if (argColors === undefined) {
        return <>{props.default !== undefined ? props.default : "n/a"}</>;
      }
      let allargs = Object.keys(argColors).map(JSON.parse);
      let styleClasses = colorSet => "fact " + Array.from(colorSet).join(" ");

      return (<>
        {allargs.map((args, i) => {
          let reason = `${props.principal} attests ${props.symbol}(${args.join(", ")})`;
          let colors = argColors[JSON.stringify(args)];
          return <span key={args}> {i > 0 && " "}
            <span title={reason}
              className={styleClasses(colors)}>
              <FormattedFact
                format={props.format}
                principal={props.principal}
                symbol={props.symbol}
                args={args}
              />
            </span>
          </span>;
        })}
      </>);
    }

    function FactInstances(props) {
      let db = props.db;
      let symbol = props.symbol;
      if (db[symbol] === undefined) {
        return <span>{" "}
          {props.default !== undefined
            ? props.default
            : "n/a"}
        </span>;
      }
      let principals = Object.keys(db[symbol]).filter(p =>
        props.principal === undefined || p === props.principal);
      return <>
        {principals.map(p =>
          <FactInstancesOfPrincipal key={p}
            format={props.format}
            default={props.default}
            principal={p}
            symbol={symbol}
            argColors={db[symbol][p]}
          />)
        }
      </>;
    }

    class FactDB extends React.Component {
      constructor(props) {
        super(props);
        this.state = {};
      }

      componentDidMount() {
        var socket = io();
        var factsheet = this;
        socket.on('fact', function (msg) {
          console.log(msg);
          let facts = factsheet.state;
          let cn = getFirstCN(msg.principal.subject);
          let symbolEntry = facts[msg.literal.symbol] || {};
          let principalEntry = symbolEntry[cn] || {};
          let args = JSON.stringify(msg.literal.arguments);
          let argsEntry = principalEntry[args] || new Set();
          argsEntry.add(msg.color);
          principalEntry[args] = argsEntry;
          symbolEntry[cn] = principalEntry;
          facts[msg.literal.symbol] = symbolEntry;
          factsheet.setState(facts);
        });
      }

      render() {
        return <></>
      }
    }

  </script>
</head>

<body>
  <div id="root"></div>
  <script type="text/babel">

    // Component that displays a list of all facts
    function AllFacts(props) {
      if (props.db === undefined) {
        return null;
      }
      return (
        <ul>{
          Object.keys(props.db).map(symbol =>
            <li key={symbol} style={{ fontFamily: "monospace" }}>
              {symbol}:
              <br />
              <FactInstances db={props.db} symbol={symbol}
                format={(principal, symbol, args) =>
                  <>{principal} attests {symbol}({args.join(", ")})</>
                } />
            </li>)}
        </ul>);
    }

    function Problems(props) {
      if (props.db === undefined) {
        return null;
      }
      return (<>
        <h2 style={{ color: "red" }}>Problems found</h2>
        <ul>
          <FactInstances db={props.db}
            symbol="message_not_received"
            format={<li>"Some model updates were sent but not received:"
                <FactInstances db={props.db}
                symbol="not_received"
                format={args => args[0]}
              />
            </li>}
          />
        </ul>
      </>
      );
    }

    class Factsheet extends FactDB {
      render() {
        return (
          <>
            <h1>Node Status</h1>

            <h2>Summary</h2>

            <p>
              All the required steps
              were
              <FactInstances db={this.state}
                symbol="required"
                format="completed successfully"
                default="not completed" />.
            </p>
            <ul>
              <li>
                <FactInstances db={this.state}
                  symbol="received_messages_were_all_sent"
                  format="All model-updates received by the aggregator were sent by a party."
                  default="Not all model-updates received by the aggregator were sent by a party." />
              </li>
              <li>
                TODO: More here, e.g. Each model update sent by a party was received by the aggregator.
              </li>
            </ul>

            <p>
              <FactInstances db={this.state}
                symbol="forbidden"
                format={<Problems db={this.state} />}
                default="No Problems were found." />
            </p>


            <h2>Configuration</h2>

            <p>
              The training process is configured to use <FactInstances db={this.state} symbol="rounds" format={args => args[0]} /> rounds
                and <FactInstances db={this.state} symbol="parties" format={args => args[0]} /> parties.
            </p>

            <p>
              The termination accuracy was
              <FactInstances db={this.state} symbol="termination_accuracy" format={args => args[0]} />{" "}
                and the
                timeout was set to <FactInstances db={this.state} symbol="max_timeout" format={args => args[0]} />.
                  </p>

            <p>
              <FactInstances db={this.state} symbol="configuration"
                format={(principal, symbol, args) => {
                  let config = jsonOfConstant(args[0]);
                  if (config.fusion.cls_ref === undefined) {
                    return null;
                  } else {
                    return <>
                      Participants {principal} uses the fusion algorithm <tt>{config.fusion.cls_ref}.</tt>
                    </>
                  }
                }
                } />
            </p>

            <h2>Participants</h2>

            <p>
              The following parties have submitted configuration information:
              <ul>
                <FactInstances db={this.state} symbol="configuration"
                  format={(principal, symbol, args) => <li>{principal}</li>} />
              </ul>
            </p>


            <h2>Model Information</h2>

            <FactInstances db={this.state} symbol="configuration"
              format={(principal, symbol, args) => {
                let config = jsonOfConstant(args[0]);
                return <>
                  <h3>Model details of {principal}</h3>

                  <ul>
                    <li> Model name: <tt>{config.model.spec.model_name}</tt> </li>
                    <li> Model definition: <tt>{config.model.spec.model_definition}</tt> </li>
                    <li> Class reference: <tt>{config.model.cls_ref}</tt> </li>
                  </ul>
                </>
              }
              } />

            <h2>All facts</h2>
            <AllFacts db={this.state} />
          </>
        );
      }
    }

    ReactDOM.render(
      <Factsheet />,
      document.getElementById('root')
    );

  </script>
  <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      Read this section for a production-ready setup with JSX:
      https://reactjs.org/docs/add-react-to-a-website.html#add-jsx-to-a-project

      In a larger project, you can use an integrated toolchain that includes JSX instead:
      https://reactjs.org/docs/create-a-new-react-app.html

      You can also use React without JSX, in which case you can remove Babel:
      https://reactjs.org/docs/react-without-jsx.html
    -->
</body>

</html>